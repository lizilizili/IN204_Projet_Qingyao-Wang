#ifndef BRICK_H_INCLUDED
#define BRICK_H_INCLUDED

/*
    There are 7 types of bricks
    for each type of brick, we have:
            four directions
            four
*/
int bricks[7][4][4][2] = {
    {{{0,-2},{0,-1},{0,0},{0,1}},{{-2,0},{-1,0},{0,0},{1,0}},{{0,-2},{0,-1},{0,0},{0,1}},{{-2,0},{-1,0},{0,0},{1,0}}},// I
    {{{0,-1},{0,0},{1,0},{1,1}},{{-1,0},{0,0},{0,-1},{1,-1}},{{0,-1},{0,0},{1,0},{1,1}},{{-1,0},{0,0},{0,-1},{1,-1}}}, // Z
    {{{0,1},{0,0},{1,0},{1,-1}},{{-1,-1},{0,-1},{0,0},{1,0}},{{0,1},{0,0},{1,0},{1,-1}},{{-1,-1},{0,-1},{0,0},{1,0}}}, // Z
    {{{1,0},{0,-1},{0,0},{0,1}},{{-1,0},{0,-1},{0,0},{1,0}},{{0,-1},{0,0},{-1,0},{0,1}},{{0,1},{-1,0},{0,0},{1,0}}}, // T
    {{{1,-1},{0,-1},{0,0},{0,1}},{{-1,0},{-1,-1},{0,0},{1,0}},{{0,-1},{0,0},{-1,1},{0,1}},{{1,1},{-1,0},{0,0},{1,0}}}, // L
    {{{1,1},{0,-1},{0,0},{0,1}},{{-1,0},{1,-1},{0,0},{1,0}},{{0,-1},{0,0},{-1,-1},{0,1}},{{-1,1},{-1,0},{0,0},{1,0}}}, // J
    {{{0,0},{0,1},{1,0},{1,1}},{{0,0},{0,1},{1,0},{1,1}},{{0,0},{0,1},{1,0},{1,1}},{{0,0},{0,1},{1,0},{1,1}}} // square
};

class brick{

public:
    int direction;
    int code;

    brick(){
        direction = 0;
        code = std::rand()%7;
    }
    void newBrick(){
        direction = 0;
        code = std::rand()%7;
    }
    brick& operator = (const brick& anotherBlock) {
        this->direction = anotherBlock.direction;
        this->code = anotherBlock.code;
        return *this;
    }
};


#endif // BRICK_H_INCLUDED
